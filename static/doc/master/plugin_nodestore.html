<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Node Store Plugin API &mdash; open62541 1.4.4-undefined documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=53a654bb"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Access Control Plugin API" href="plugin_accesscontrol.html" />
    <link rel="prev" title="Logging Plugin API" href="plugin_log.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="toc.html" class="icon icon-home">
            open62541
              <img src="_static/open62541_html.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="core_concepts.html">Core Concepts of OPC UA</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building open62541</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Data Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="server.html">Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="client.html">Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="pubsub.html">PubSub</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="common.html">Common Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nodeset_compiler.html">XML Nodeset Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="statuscodes.html">StatusCodes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="plugin.html">Plugin API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="plugin_log.html">Logging Plugin API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Node Store Plugin API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#node-lifecycle-constructors-destructors-and-node-contexts">Node Lifecycle: Constructors, Destructors and Node Contexts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#global-node-lifecycle">Global Node Lifecycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node-type-lifecycle">Node Type Lifecycle</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#referencetype-bitfield-representation">ReferenceType Bitfield Representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node-pointer">Node Pointer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-node-attributes">Base Node Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variablenode">VariableNode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#value-callback">Value Callback</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#variabletypenode">VariableTypeNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#methodnode">MethodNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#objectnode">ObjectNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#objecttypenode">ObjectTypeNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#referencetypenode">ReferenceTypeNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#datatypenode">DataTypeNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#viewnode">ViewNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node-union">Node Union</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nodestore">Nodestore</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="plugin_accesscontrol.html">Access Control Plugin API</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugin_eventloop.html">Event Loop Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugin_securitypolicy.html">SecurityPolicy</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugin_securitypolicy.html#pubsub-securitypolicy">PubSub SecurityPolicy</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="toc.html">open62541</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="toc.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="plugin.html">Plugin API</a></li>
      <li class="breadcrumb-item active">Node Store Plugin API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/plugin_nodestore.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="node-store-plugin-api">
<h1>Node Store Plugin API<a class="headerlink" href="#node-store-plugin-api" title="Link to this heading">¶</a></h1>
<p><strong>Warning!!</strong> The structures defined in this section are only relevant for
the developers of custom Nodestores. The interaction with the information
model is possible only via the OPC UA <a class="reference internal" href="core_concepts.html#services"><span class="std std-ref">Services</span></a>. So the following
sections are purely informational so that users may have a clear mental
model of the underlying representation.</p>
<section id="node-lifecycle-constructors-destructors-and-node-contexts">
<span id="node-lifecycle"></span><h2>Node Lifecycle: Constructors, Destructors and Node Contexts<a class="headerlink" href="#node-lifecycle-constructors-destructors-and-node-contexts" title="Link to this heading">¶</a></h2>
<p>To finalize the instantiation of a node, a (user-defined) constructor
callback is executed. There can be both a global constructor for all nodes
and node-type constructor specific to the TypeDefinition of the new node
(attached to an ObjectTypeNode or VariableTypeNode).</p>
<p>In the hierarchy of ObjectTypes and VariableTypes, only the constructor of
the (lowest) type defined for the new node is executed. Note that every
Object and Variable can have only one <code class="docutils literal notranslate"><span class="pre">isTypeOf</span></code> reference. But type-nodes
can technically have several <code class="docutils literal notranslate"><span class="pre">hasSubType</span></code> references to implement multiple
inheritance. Issues of (multiple) inheritance in the constructor need to be
solved by the user.</p>
<p>When a node is destroyed, the node-type destructor is called before the
global destructor. So the overall node lifecycle is as follows:</p>
<ol class="arabic simple">
<li><p>Global Constructor (set in the server config)</p></li>
<li><p>Node-Type Constructor (for VariableType or ObjectTypes)</p></li>
<li><p>(Usage-period of the Node)</p></li>
<li><p>Node-Type Destructor</p></li>
<li><p>Global Destructor</p></li>
</ol>
<p>The constructor and destructor callbacks can be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and are not
used in that case. If the node-type constructor fails, the global destructor
will be called before removing the node. The destructors are assumed to never
fail.</p>
<p>Every node carries a user-context and a constructor-context pointer. The
user-context is used to attach custom data to a node. But the (user-defined)
constructors and destructors may replace the user-context pointer if they
wish to do so. The initial value for the constructor-context is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
When the <code class="docutils literal notranslate"><span class="pre">AddNodes</span></code> service is used over the network, the user-context
pointer of the new node is also initially set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<section id="global-node-lifecycle">
<h3>Global Node Lifecycle<a class="headerlink" href="#global-node-lifecycle" title="Link to this heading">¶</a></h3>
<p>Global constructor and destructor callbacks used for every node type.
To be set in the server config.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Can be NULL. May replace the nodeContext */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">constructor</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">nodeContext</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Can be NULL. The context cannot be replaced since the node is destroyed</span>
<span class="cm">     * immediately afterwards anyway. */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Can be NULL. Called during recursive node instantiation. While mandatory</span>
<span class="cm">     * child nodes are automatically created if not already present, optional child</span>
<span class="cm">     * nodes are not. This callback can be used to define whether an optional child</span>
<span class="cm">     * node should be created.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param sourceNodeId Source node from the type definition. If the new node</span>
<span class="cm">     *        shall be created, it will be a copy of this node.</span>
<span class="cm">     * @param targetParentNodeId Parent of the potential new child node</span>
<span class="cm">     * @param referenceTypeId Identifies the reference type which that the parent</span>
<span class="cm">     *        node has to the new node.</span>
<span class="cm">     * @return Return UA_TRUE if the child node shall be instantiated,</span>
<span class="cm">     *         UA_FALSE otherwise. */</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">createOptionalChild</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sourceNodeId</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">targetParentNodeId</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">referenceTypeId</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Can be NULL. Called when a node is to be copied during recursive</span>
<span class="cm">     * node instantiation. Allows definition of the NodeId for the new node.</span>
<span class="cm">     * If the callback is set to NULL or the resulting NodeId is UA_NODEID_NUMERIC(X,0)</span>
<span class="cm">     * an unused nodeid in namespace X will be used. E.g. passing UA_NODEID_NULL will</span>
<span class="cm">     * result in a NodeId in namespace 0.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param sourceNodeId Source node of the copy operation</span>
<span class="cm">     * @param targetParentNodeId Parent node of the new node</span>
<span class="cm">     * @param referenceTypeId Identifies the reference type which that the parent</span>
<span class="cm">     *        node has to the new node. */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">generateChildNodeId</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sourceNodeId</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">targetParentNodeId</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">referenceTypeId</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">targetNodeId</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_GlobalNodeLifecycle</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="node-type-lifecycle">
<h3>Node Type Lifecycle<a class="headerlink" href="#node-type-lifecycle" title="Link to this heading">¶</a></h3>
<p>Constructor and destructors for specific object and variable types.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Can be NULL. May replace the nodeContext */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">constructor</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">typeNodeId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">typeNodeContext</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">nodeContext</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Can be NULL. May replace the nodeContext. */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">typeNodeId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">typeNodeContext</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">nodeContext</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_NodeTypeLifecycle</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="referencetype-bitfield-representation">
<h2>ReferenceType Bitfield Representation<a class="headerlink" href="#referencetype-bitfield-representation" title="Link to this heading">¶</a></h2>
<p>ReferenceTypes have an alternative represention as an index into a bitfield
for fast comparison. The index is generated when the corresponding
ReferenceTypeNode is added. By bounding the number of ReferenceTypes that can
exist in the server, the bitfield can represent a set of an combination of
ReferenceTypes.</p>
<p>Every ReferenceTypeNode contains a bitfield with the set of all its subtypes.
This speeds up the Browse services substantially.</p>
<p>The following ReferenceTypes have a fixed index. The NS0 bootstrapping
creates these ReferenceTypes in-order.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define UA_REFERENCETYPEINDEX_REFERENCES 0</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASSUBTYPE 1</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_AGGREGATES 2</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HIERARCHICALREFERENCES 3</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_NONHIERARCHICALREFERENCES 4</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASCHILD 5</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_ORGANIZES 6</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASEVENTSOURCE 7</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASMODELLINGRULE 8</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASENCODING 9</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASDESCRIPTION 10</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASTYPEDEFINITION 11</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_GENERATESEVENT 12</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASPROPERTY 13</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASCOMPONENT 14</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASNOTIFIER 15</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASORDEREDCOMPONENT 16</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASINTERFACE 17</span>

<span class="cm">/* The maximum number of ReferrenceTypes. Must be a multiple of 32. */</span>
<span class="cp">#define UA_REFERENCETYPESET_MAX 128</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">bits</span><span class="p">[</span><span class="n">UA_REFERENCETYPESET_MAX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">UA_REFERENCETYPESET_NONE</span><span class="p">;</span>
<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">UA_REFERENCETYPESET_ALL</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">UA_INLINE</span><span class="w"> </span><span class="kt">void</span>
<span class="n">UA_ReferenceTypeSet_init</span><span class="p">(</span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_ReferenceTypeSet</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">UA_INLINE</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span>
<span class="n">UA_REFTYPESET</span><span class="p">(</span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">set</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ReferenceTypeSet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
<span class="w">    </span><span class="n">set</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">UA_UInt32</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">UA_INLINE</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span>
<span class="n">UA_ReferenceTypeSet_union</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">setA</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">setB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">set</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">UA_REFERENCETYPESET_MAX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">set</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">setA</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">setB</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">UA_INLINE</span><span class="w"> </span><span class="n">UA_Boolean</span>
<span class="n">UA_ReferenceTypeSet_contains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!!</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(((</span><span class="n">UA_UInt32</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="node-pointer">
<h2>Node Pointer<a class="headerlink" href="#node-pointer" title="Link to this heading">¶</a></h2>
<p>The “native” format for reference between nodes is the ExpandedNodeId. That
is, references can also point to external servers. In practice, most
references point to local nodes using numerical NodeIds from the
standard-defined namespace zero. In order to save space (and time),
pointer-tagging is used for compressed “NodePointer” representations.
Numerical NodeIds are immediately contained in the pointer. Full NodeIds and
ExpandedNodeIds are behind a pointer indirection. If the Nodestore supports
it, a NodePointer can also be an actual pointer to the target node.</p>
<p>Depending on the processor architecture, some numerical NodeIds don’t fit
into an immediate encoding and are kept as pointers. ExpandedNodeIds may be
internally translated to “normal” NodeIds. Use the provided functions to
generate NodePointers that fit the assumptions for the local architecture.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Forward declaration. All node structures begin with the NodeHead. */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">UA_NodeHead</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_NodeHead</span><span class="w"> </span><span class="n">UA_NodeHead</span><span class="p">;</span>

<span class="cm">/* Tagged Pointer structure. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">immediate</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* 00: Small numerical NodeId */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* 01: Pointer to NodeId */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">expandedId</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 10: Pointer to ExternalNodeId */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">;</span><span class="w">             </span><span class="cm">/* 11: Pointer to a node */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_NodePointer</span><span class="p">;</span>

<span class="cm">/* Sets the pointer to an immediate NodeId &quot;ns=0;i=0&quot; similar to a freshly</span>
<span class="cm"> * initialized UA_NodeId */</span>
<span class="k">static</span><span class="w"> </span><span class="n">UA_INLINE</span><span class="w"> </span><span class="kt">void</span>
<span class="n">UA_NodePointer_init</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="o">*</span><span class="n">np</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">np</span><span class="o">-&gt;</span><span class="n">immediate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="cm">/* NodeId and ExpandedNodeId targets are freed */</span>
<span class="kt">void</span>
<span class="n">UA_NodePointer_clear</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="o">*</span><span class="n">np</span><span class="p">);</span>

<span class="cm">/* Makes a deep copy */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_NodePointer_copy</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">);</span>

<span class="cm">/* Test if an ExpandedNodeId or a local NodeId */</span>
<span class="n">UA_Boolean</span>
<span class="nf">UA_NodePointer_isLocal</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">np</span><span class="p">);</span>

<span class="n">UA_Order</span>
<span class="nf">UA_NodePointer_order</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="n">UA_INLINE</span><span class="w"> </span><span class="n">UA_Boolean</span>
<span class="n">UA_NodePointer_equal</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">UA_NodePointer_order</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UA_ORDER_EQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cannot fail. The resulting NodePointer can point to the memory from the</span>
<span class="cm"> * NodeId. Make a deep copy if required. */</span>
<span class="n">UA_NodePointer</span>
<span class="n">UA_NodePointer_fromNodeId</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="cm">/* Cannot fail. The resulting NodePointer can point to the memory from the</span>
<span class="cm"> * ExpandedNodeId. Make a deep copy if required. */</span>
<span class="n">UA_NodePointer</span>
<span class="nf">UA_NodePointer_fromExpandedNodeId</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="cm">/* Can point to the memory from the NodePointer */</span>
<span class="n">UA_ExpandedNodeId</span>
<span class="nf">UA_NodePointer_toExpandedNodeId</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">np</span><span class="p">);</span>

<span class="cm">/* Can point to the memory from the NodePointer. Discards the ServerIndex and</span>
<span class="cm"> * NamespaceUri of a potential ExpandedNodeId inside the NodePointer. Test</span>
<span class="cm"> * before if the NodePointer is local. */</span>
<span class="n">UA_NodeId</span>
<span class="nf">UA_NodePointer_toNodeId</span><span class="p">(</span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">np</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="base-node-attributes">
<h2>Base Node Attributes<a class="headerlink" href="#base-node-attributes" title="Link to this heading">¶</a></h2>
<p>Nodes contain attributes according to their node type. The base node
attributes are common to all node types. In the OPC UA <a class="reference internal" href="core_concepts.html#services"><span class="std std-ref">Services</span></a>,
attributes are referred to via the <a class="reference internal" href="types.html#nodeid"><span class="std std-ref">NodeId</span></a> of the containing node and
an integer <a class="reference internal" href="common.html#attribute-id"><span class="std std-ref">Attribute Id</span></a>.</p>
<p>Internally, open62541 uses <code class="docutils literal notranslate"><span class="pre">UA_Node</span></code> in places where the exact node type is
not known or not important. The <code class="docutils literal notranslate"><span class="pre">nodeClass</span></code> attribute is used to ensure the
correctness of casting from <code class="docutils literal notranslate"><span class="pre">UA_Node</span></code> to a specific node type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">targetId</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Has to be the first entry */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">targetNameHash</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Hash of the target&#39;s BrowseName. Set to zero</span>
<span class="cm">                               * if the target is remote. */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ReferenceTarget</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ReferenceTarget</span><span class="w"> </span><span class="n">target</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Has to be the first entry */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">targetIdHash</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Hash of the targetId */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">idTreeEntry</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">nameTreeEntry</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ReferenceTargetTreeElem</span><span class="p">;</span>


<span class="cm">/* List of reference targets with the same reference type and direction. Uses</span>
<span class="cm"> * either an array or a tree structure. The SDK will not change the type of</span>
<span class="cm"> * reference target structure internally. The nodestore implementations may</span>
<span class="cm"> * switch internally when a node is updated.</span>
<span class="cm"> *</span>
<span class="cm"> * The recommendation is to switch to a tree once the number of refs &gt; 8. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Organize the references in an array. Uses less memory, but incurs</span>
<span class="cm">         * lookups in linear time. Recommended if the number of references is</span>
<span class="cm">         * known to be small. */</span>
<span class="w">        </span><span class="n">UA_ReferenceTarget</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Organize the references in a tree for fast lookup. Use</span>
<span class="cm">         * UA_Node_addReference and UA_Node_deleteReference to modify the</span>
<span class="cm">         * tree-structure. The binary tree implementation (and absolute ordering</span>
<span class="cm">         * / duplicate browseNames are allowed) are not exposed otherwise in the</span>
<span class="cm">         * public API. */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="o">*</span><span class="n">idRoot</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Lookup based on target id */</span>
<span class="w">            </span><span class="n">UA_ReferenceTargetTreeElem</span><span class="w"> </span><span class="o">*</span><span class="n">nameRoot</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Lookup based on browseName*/</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">targets</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">targetsSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">hasRefTree</span><span class="p">;</span><span class="w"> </span><span class="cm">/* RefTree or RefArray? */</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">referenceTypeIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isInverse</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_NodeReferenceKind</span><span class="p">;</span>

<span class="cm">/* Iterate over the references. Aborts when the first callback return a non-NULL</span>
<span class="cm"> * pointer and returns that pointer. Do not modify the reference targets during</span>
<span class="cm"> * the iteration. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span>
<span class="p">(</span><span class="o">*</span><span class="n">UA_NodeReferenceKind_iterateCallback</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">UA_ReferenceTarget</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_NodeReferenceKind_iterate</span><span class="p">(</span><span class="n">UA_NodeReferenceKind</span><span class="w"> </span><span class="o">*</span><span class="n">rk</span><span class="p">,</span>
<span class="w">                             </span><span class="n">UA_NodeReferenceKind_iterateCallback</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="cm">/* Returns the entry for the targetId or NULL if not found */</span>
<span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTarget</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_NodeReferenceKind_findTarget</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeReferenceKind</span><span class="w"> </span><span class="o">*</span><span class="n">rk</span><span class="p">,</span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">targetId</span><span class="p">);</span>

<span class="cm">/* Switch between array and tree representation. Does nothing upon error (e.g.</span>
<span class="cm"> * out-of-memory). */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_NodeReferenceKind_switch</span><span class="p">(</span><span class="n">UA_NodeReferenceKind</span><span class="w"> </span><span class="o">*</span><span class="n">rk</span><span class="p">);</span>

<span class="cm">/* Singly-linked LocalizedText list */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_LocalizedTextListEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_LocalizedTextListEntry</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_LocalizedText</span><span class="w"> </span><span class="n">localizedText</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_LocalizedTextListEntry</span><span class="p">;</span>

<span class="cm">/* Every Node starts with these attributes */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">UA_NodeHead</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_NodeClass</span><span class="w"> </span><span class="n">nodeClass</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_QualifiedName</span><span class="w"> </span><span class="n">browseName</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* A node can have different localizations for displayName and description.</span>
<span class="cm">     * The server selects a suitable localization depending on the locale ids</span>
<span class="cm">     * that are set for the current session.</span>
<span class="cm">     *</span>
<span class="cm">     * Locales are added simply by writing a LocalizedText value with a new</span>
<span class="cm">     * locale. A locale can be removed by writing a LocalizedText value of the</span>
<span class="cm">     * corresponding locale with an empty text field. */</span>
<span class="w">    </span><span class="n">UA_LocalizedTextListEntry</span><span class="w"> </span><span class="o">*</span><span class="n">displayName</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_LocalizedTextListEntry</span><span class="w"> </span><span class="o">*</span><span class="n">description</span><span class="p">;</span>

<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">writeMask</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">referencesSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_NodeReferenceKind</span><span class="w"> </span><span class="o">*</span><span class="n">references</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Members specific to open62541 */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">constructed</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Constructors were called */</span>
<span class="cp">#ifdef UA_ENABLE_SUBSCRIPTIONS</span>
<span class="w">    </span><span class="n">UA_MonitoredItem</span><span class="w"> </span><span class="o">*</span><span class="n">monitoredItems</span><span class="p">;</span><span class="w"> </span><span class="cm">/* MonitoredItems for Events and immediate</span>
<span class="cm">                                       * DataChanges (no sampling interval). */</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="variablenode">
<h2>VariableNode<a class="headerlink" href="#variablenode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Indicates whether a variable contains data inline or whether it points to an</span>
<span class="cm"> * external data source */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_VALUESOURCE_DATA</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_VALUESOURCE_DATASOURCE</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ValueSource</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Called before the value attribute is read. It is possible to write into the</span>
<span class="cm">     * value attribute during onRead (using the write service). The node is</span>
<span class="cm">     * re-opened afterwards so that changes are considered in the following read</span>
<span class="cm">     * operation.</span>
<span class="cm">     *</span>
<span class="cm">     * @param handle Points to user-provided data for the callback.</span>
<span class="cm">     * @param nodeid The identifier of the node.</span>
<span class="cm">     * @param data Points to the current node value.</span>
<span class="cm">     * @param range Points to the numeric range the client wants to read from</span>
<span class="cm">     *        (or NULL). */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">onRead</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeid</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Called after writing the value attribute. The node is re-opened after</span>
<span class="cm">     * writing so that the new value is visible in the callback.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @sessionId The identifier of the session</span>
<span class="cm">     * @sessionContext Additional data attached to the session</span>
<span class="cm">     *                 in the access control layer</span>
<span class="cm">     * @param nodeid The identifier of the node.</span>
<span class="cm">     * @param nodeUserContext Additional data attached to the node by</span>
<span class="cm">     *        the user.</span>
<span class="cm">     * @param nodeConstructorContext Additional data attached to the node</span>
<span class="cm">     *        by the type constructor(s).</span>
<span class="cm">     * @param range Points to the numeric range the client wants to write to (or</span>
<span class="cm">     *        NULL). */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">onWrite</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ValueCallback</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Copies the data from the source into the provided value.</span>
<span class="cm">     *</span>
<span class="cm">     * !! ZERO-COPY OPERATIONS POSSIBLE !!</span>
<span class="cm">     * It is not required to return a copy of the actual content data. You can</span>
<span class="cm">     * return a pointer to memory owned by the user. Memory can be reused</span>
<span class="cm">     * between read callbacks of a DataSource, as the result is already encoded</span>
<span class="cm">     * on the network buffer between each read operation.</span>
<span class="cm">     *</span>
<span class="cm">     * To use zero-copy reads, set the value of the `value-&gt;value` Variant</span>
<span class="cm">     * without copying, e.g. with `UA_Variant_setScalar`. Then, also set</span>
<span class="cm">     * `value-&gt;value.storageType` to `UA_VARIANT_DATA_NODELETE` to prevent the</span>
<span class="cm">     * memory being cleaned up. Don&#39;t forget to also set `value-&gt;hasValue` to</span>
<span class="cm">     * true to indicate the presence of a value.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param nodeId The identifier of the node being read from</span>
<span class="cm">     * @param nodeContext Additional data attached to the node by the user</span>
<span class="cm">     * @param includeSourceTimeStamp If true, then the datasource is expected to</span>
<span class="cm">     *        set the source timestamp in the returned value</span>
<span class="cm">     * @param range If not null, then the datasource shall return only a</span>
<span class="cm">     *        selection of the (nonscalar) data. Set</span>
<span class="cm">     *        UA_STATUSCODE_BADINDEXRANGEINVALID in the value if this does not</span>
<span class="cm">     *        apply</span>
<span class="cm">     * @param value The (non-null) DataValue that is returned to the client. The</span>
<span class="cm">     *        data source sets the read data, the result status and optionally a</span>
<span class="cm">     *        sourcetimestamp.</span>
<span class="cm">     * @return Returns a status code for logging. Error codes intended for the</span>
<span class="cm">     *         original caller are set in the value. If an error is returned,</span>
<span class="cm">     *         then no releasing of the value is done</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">includeSourceTimeStamp</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Write into a data source. This method pointer can be NULL if the</span>
<span class="cm">     * operation is unsupported.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param nodeId The identifier of the node being written to</span>
<span class="cm">     * @param nodeContext Additional data attached to the node by the user</span>
<span class="cm">     * @param range If not NULL, then the datasource shall return only a</span>
<span class="cm">     *        selection of the (nonscalar) data. Set</span>
<span class="cm">     *        UA_STATUSCODE_BADINDEXRANGEINVALID in the value if this does not</span>
<span class="cm">     *        apply</span>
<span class="cm">     * @param value The (non-NULL) DataValue that has been written by the client.</span>
<span class="cm">     *        The data source contains the written data, the result status and</span>
<span class="cm">     *        optionally a sourcetimestamp</span>
<span class="cm">     * @return Returns a status code for logging. Error codes intended for the</span>
<span class="cm">     *         original caller are set in the value. If an error is returned,</span>
<span class="cm">     *         then no releasing of the value is done</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">,</span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DataSource</span><span class="p">;</span>
</pre></div>
</div>
<section id="value-callback">
<span id="id1"></span><h3>Value Callback<a class="headerlink" href="#value-callback" title="Link to this heading">¶</a></h3>
<p>Value Callbacks can be attached to variable and variable type nodes. If
not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, they are called before reading and after writing respectively.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Called before the value attribute is read. The external value source can be</span>
<span class="cm">     * be updated and/or locked during this notification call. After this function returns</span>
<span class="cm">     * to the core, the external value source is readed immediately.</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">notificationRead</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeid</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Called after writing the value attribute. The node is re-opened after</span>
<span class="cm">     * writing so that the new value is visible in the callback.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @sessionId The identifier of the session</span>
<span class="cm">     * @sessionContext Additional data attached to the session</span>
<span class="cm">     *                 in the access control layer</span>
<span class="cm">     * @param nodeid The identifier of the node.</span>
<span class="cm">     * @param nodeUserContext Additional data attached to the node by</span>
<span class="cm">     *        the user.</span>
<span class="cm">     * @param nodeConstructorContext Additional data attached to the node</span>
<span class="cm">     *        by the type constructor(s).</span>
<span class="cm">     * @param range Points to the numeric range the client wants to write to (or</span>
<span class="cm">     *        NULL). */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">userWrite</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">,</span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ExternalValueCallback</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_VALUEBACKENDTYPE_NONE</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_VALUEBACKENDTYPE_INTERNAL</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_VALUEBACKENDTYPE_DATA_SOURCE_CALLBACK</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_VALUEBACKENDTYPE_EXTERNAL</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ValueBackendType</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ValueBackendType</span><span class="w"> </span><span class="n">backendType</span><span class="p">;</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="n">UA_ValueCallback</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">internal</span><span class="p">;</span>
<span class="w">        </span><span class="n">UA_DataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">**</span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="n">UA_ExternalValueCallback</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">external</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">backend</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ValueBackend</span><span class="p">;</span>

<span class="cp">#define UA_NODE_VARIABLEATTRIBUTES                                      \</span>
<span class="cp">    </span><span class="cm">/* Constraints on possible values */</span><span class="cp">                                \</span>
<span class="cp">    UA_NodeId dataType;                                                 \</span>
<span class="cp">    UA_Int32 valueRank;                                                 \</span>
<span class="cp">    size_t arrayDimensionsSize;                                         \</span>
<span class="cp">    UA_UInt32 *arrayDimensions;                                         \</span>
<span class="cp">                                                                        \</span>
<span class="cp">    UA_ValueBackend valueBackend;                                       \</span>
<span class="cp">                                                                        \</span>
<span class="cp">    </span><span class="cm">/* The current value */</span><span class="cp">                                             \</span>
<span class="cp">    UA_ValueSource valueSource;                                         \</span>
<span class="cp">    union {                                                             \</span>
<span class="cp">        struct {                                                        \</span>
<span class="cp">            UA_DataValue value;                                         \</span>
<span class="cp">            UA_ValueCallback callback;                                  \</span>
<span class="cp">        } data;                                                         \</span>
<span class="cp">        UA_DataSource dataSource;                                       \</span>
<span class="cp">    } value;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_NODE_VARIABLEATTRIBUTES</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">accessLevel</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Double</span><span class="w"> </span><span class="n">minimumSamplingInterval</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">historizing</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Members specific to open62541 */</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isDynamic</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Some variables are &quot;static&quot; in the sense that they</span>
<span class="cm">                           * are not attached to a dynamic process in the</span>
<span class="cm">                           * background. Only dynamic variables conserve source</span>
<span class="cm">                           * and server timestamp for the value attribute.</span>
<span class="cm">                           * Static variables have timestamps of &quot;now&quot;. */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_VariableNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="variabletypenode">
<h2>VariableTypeNode<a class="headerlink" href="#variabletypenode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_NODE_VARIABLEATTRIBUTES</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isAbstract</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Members specific to open62541 */</span>
<span class="w">    </span><span class="n">UA_NodeTypeLifecycle</span><span class="w"> </span><span class="n">lifecycle</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_VariableTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="methodnode">
<h2>MethodNode<a class="headerlink" href="#methodnode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">UA_StatusCode</span>
<span class="p">(</span><span class="o">*</span><span class="n">UA_MethodCallback</span><span class="p">)(</span><span class="n">UA_Server</span><span class="w"> </span><span class="o">*</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">methodId</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">methodContext</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">objectId</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">objectContext</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">inputSize</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">outputSize</span><span class="p">,</span>
<span class="w">                     </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">);</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">executable</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Members specific to open62541 */</span>
<span class="w">    </span><span class="n">UA_MethodCallback</span><span class="w"> </span><span class="n">method</span><span class="p">;</span>
<span class="cp">#if UA_MULTITHREADING &gt;= 100</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">async</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Indicates an async method call */</span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_MethodNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="objectnode">
<h2>ObjectNode<a class="headerlink" href="#objectnode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">eventNotifier</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ObjectNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="objecttypenode">
<h2>ObjectTypeNode<a class="headerlink" href="#objecttypenode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isAbstract</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Members specific to open62541 */</span>
<span class="w">    </span><span class="n">UA_NodeTypeLifecycle</span><span class="w"> </span><span class="n">lifecycle</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ObjectTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="referencetypenode">
<h2>ReferenceTypeNode<a class="headerlink" href="#referencetypenode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isAbstract</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">symmetric</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_LocalizedText</span><span class="w"> </span><span class="n">inverseName</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Members specific to open62541 */</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">referenceTypeIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">subTypes</span><span class="p">;</span><span class="w"> </span><span class="cm">/* contains the type itself as well */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ReferenceTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="datatypenode">
<h2>DataTypeNode<a class="headerlink" href="#datatypenode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isAbstract</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DataTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="viewnode">
<h2>ViewNode<a class="headerlink" href="#viewnode" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">eventNotifier</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">containsNoLoops</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ViewNode</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="node-union">
<h2>Node Union<a class="headerlink" href="#node-union" title="Link to this heading">¶</a></h2>
<p>A union that represents any kind of node. The node head can always be used.
Check the NodeClass before accessing specific content.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeHead</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_VariableNode</span><span class="w"> </span><span class="n">variableNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_VariableTypeNode</span><span class="w"> </span><span class="n">variableTypeNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_MethodNode</span><span class="w"> </span><span class="n">methodNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ObjectNode</span><span class="w"> </span><span class="n">objectNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ObjectTypeNode</span><span class="w"> </span><span class="n">objectTypeNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ReferenceTypeNode</span><span class="w"> </span><span class="n">referenceTypeNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_DataTypeNode</span><span class="w"> </span><span class="n">dataTypeNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ViewNode</span><span class="w"> </span><span class="n">viewNode</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_Node</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="nodestore">
<h2>Nodestore<a class="headerlink" href="#nodestore" title="Link to this heading">¶</a></h2>
<p>The following definitions are used for implementing custom node storage
backends. <strong>Most users will want to use the default nodestore and don’t need
to work with the nodestore API</strong>.</p>
<p>Outside of custom nodestore implementations, users should not manually edit
nodes. Please use the OPC UA services for that. Otherwise, all consistency
checks are omitted. This can crash the application eventually.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">UA_NodestoreVisitor</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">visitorCtx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Nodestore context and lifecycle */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clear</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* The following definitions are used to create empty nodes of the different</span>
<span class="cm">     * node types. The memory is managed by the nodestore. Therefore, the node</span>
<span class="cm">     * has to be removed via a special deleteNode function. (If the new node is</span>
<span class="cm">     * not added to the nodestore.) */</span>
<span class="w">    </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">newNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodeClass</span><span class="w"> </span><span class="n">nodeClass</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">deleteNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ``Get`` returns a pointer to an immutable node. Call ``releaseNode`` to</span>
<span class="cm">     * indicate when the pointer is no longer accessed.</span>
<span class="cm">     *</span>
<span class="cm">     * It can be indicated if only a subset of the attributes and referencs need</span>
<span class="cm">     * to be accessed. That is relevant when the nodestore accesses a slow</span>
<span class="cm">     * storage backend for the attributes. The attribute mask is a bitfield with</span>
<span class="cm">     * ORed entries from UA_NodeAttributesMask. If the attributes mask is empty,</span>
<span class="cm">     * then only the non-standard entries (context-pointer, callbacks, etc.) are</span>
<span class="cm">     * returned.</span>
<span class="cm">     *</span>
<span class="cm">     * The returned node always contains the context-pointer and other fields</span>
<span class="cm">     * specific to open626541 (not official attributes).</span>
<span class="cm">     *</span>
<span class="cm">     * The NodeStore does not complain if attributes and references that don&#39;t</span>
<span class="cm">     * exist (for that node) are requested. Attributes and references in</span>
<span class="cm">     * addition to those specified can be returned. For example, if the full</span>
<span class="cm">     * node already is kept in memory by the Nodestore. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                               </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">attributeMask</span><span class="p">,</span>
<span class="w">                               </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">references</span><span class="p">,</span>
<span class="w">                               </span><span class="n">UA_BrowseDirection</span><span class="w"> </span><span class="n">referenceDirections</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Similar to the normal ``getNode``. But it can take advantage of the</span>
<span class="cm">     * NodePointer structure, e.g. if it contains a direct pointer. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getNodeFromPtr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">attributeMask</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">references</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">UA_BrowseDirection</span><span class="w"> </span><span class="n">referenceDirections</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ``GetEditNode`` returns a pointer to a mutable version of the node. A</span>
<span class="cm">     * plugin implementation that keeps all nodes in RAM can return the same</span>
<span class="cm">     * pointer from ``GetNode`` and ``GetEditNode``. The differences are more</span>
<span class="cm">     * important if, for example, nodes are stored in a backend database. Then</span>
<span class="cm">     * the ``GetEditNode`` version is used to indicate that modifications are</span>
<span class="cm">     * being made.</span>
<span class="cm">     *</span>
<span class="cm">     * Call ``releaseNode`` to indicate when editing is done and the pointer is</span>
<span class="cm">     * no longer used. Note that changes are not (necessarily) visible in other</span>
<span class="cm">     * (const) node-pointers that were previously retrieved. Changes are however</span>
<span class="cm">     * visible in all newly retrieved node-pointers for the given NodeId after</span>
<span class="cm">     * calling ``releaseNode``.</span>
<span class="cm">     *</span>
<span class="cm">     * The attribute-mask and reference-description indicate if only a subset of</span>
<span class="cm">     * the attributes and referencs are to be modified. Other attributes and</span>
<span class="cm">     * references shall not be changed. */</span>
<span class="w">    </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getEditNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                             </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">attributeMask</span><span class="p">,</span>
<span class="w">                             </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">references</span><span class="p">,</span>
<span class="w">                             </span><span class="n">UA_BrowseDirection</span><span class="w"> </span><span class="n">referenceDirections</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Similar to ``getEditNode``. But it can take advantage of the NodePointer</span>
<span class="cm">     * structure, e.g. if it contains a direct pointer. */</span>
<span class="w">    </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getEditNodeFromPtr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodePointer</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">attributeMask</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="n">references</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UA_BrowseDirection</span><span class="w"> </span><span class="n">referenceDirections</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Release a node that has been retrieved with ``getNode`` or</span>
<span class="cm">     * ``getNodeFromPtr``. */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">releaseNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Returns an editable copy of a node (needs to be deleted with the</span>
<span class="cm">     * deleteNode function or inserted / replaced into the nodestore). */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getNodeCopy</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">**</span><span class="n">outNode</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Inserts a new node into the nodestore. If the NodeId is zero, then a</span>
<span class="cm">     * fresh numeric NodeId is assigned. If insertion fails, the node is</span>
<span class="cm">     * deleted. */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">insertNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">,</span>
<span class="w">                                </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">addedNodeId</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* To replace a node, get an editable copy of the node, edit and replace</span>
<span class="cm">     * with this function. If the node was already replaced since the copy was</span>
<span class="cm">     * made, UA_STATUSCODE_BADINTERNALERROR is returned. If the NodeId is not</span>
<span class="cm">     * found, UA_STATUSCODE_BADNODEIDUNKNOWN is returned. In both error cases,</span>
<span class="cm">     * the editable node is deleted. */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">replaceNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Removes a node from the nodestore. */</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">removeNode</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">nodeId</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Maps the ReferenceTypeIndex used for the references to the NodeId of the</span>
<span class="cm">     * ReferenceType. The returned pointer is stable until the Nodestore is</span>
<span class="cm">     * deleted. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getReferenceTypeId</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">refTypeIndex</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Execute a callback for every node in the nodestore. */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iterate</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span><span class="w"> </span><span class="n">UA_NodestoreVisitor</span><span class="w"> </span><span class="n">visitor</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">visitorCtx</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_Nodestore</span><span class="p">;</span>

<span class="cm">/* Attributes must be of a matching type (VariableAttributes, ObjectAttributes,</span>
<span class="cm"> * and so on). The attributes are copied. Note that the attributes structs do</span>
<span class="cm"> * not contain NodeId, NodeClass and BrowseName. The NodeClass of the node needs</span>
<span class="cm"> * to be correctly set before calling this method. UA_Node_clear is called on</span>
<span class="cm"> * the node when an error occurs internally. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_setAttributes</span><span class="p">(</span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">attributes</span><span class="p">,</span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">attributeType</span><span class="p">);</span>

<span class="cm">/* Reset the destination node and copy the content of the source */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_copy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">);</span>

<span class="cm">/* Allocate new node and copy the values from src */</span>
<span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_Node_copy_alloc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">);</span>

<span class="cm">/* Add a single reference to the node */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_addReference</span><span class="p">(</span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">refTypeIndex</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isForward</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">targetNodeId</span><span class="p">,</span>
<span class="w">                     </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">targetBrowseNameHash</span><span class="p">);</span>

<span class="cm">/* Delete a single reference from the node */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_deleteReference</span><span class="p">(</span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">refTypeIndex</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">isForward</span><span class="p">,</span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">targetNodeId</span><span class="p">);</span>

<span class="cm">/* Deletes references from the node which are not matching any type in the given</span>
<span class="cm"> * array. Could be used to e.g. delete all the references, except</span>
<span class="cm"> * &#39;HASMODELINGRULE&#39; */</span>
<span class="kt">void</span>
<span class="nf">UA_Node_deleteReferencesSubset</span><span class="p">(</span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ReferenceTypeSet</span><span class="w"> </span><span class="o">*</span><span class="n">keepSet</span><span class="p">);</span>

<span class="cm">/* Delete all references of the node */</span>
<span class="kt">void</span>
<span class="nf">UA_Node_deleteReferences</span><span class="p">(</span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/* Remove all malloc&#39;ed members of the node and reset */</span>
<span class="kt">void</span>
<span class="nf">UA_Node_clear</span><span class="p">(</span><span class="n">UA_Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="plugin_log.html" class="btn btn-neutral float-left" title="Logging Plugin API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="plugin_accesscontrol.html" class="btn btn-neutral float-right" title="Access Control Plugin API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Information Modelling &mdash; open62541 1.2.0-5-gcc3a3d396-dirty documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Server" href="server.html" />
    <link rel="prev" title="Services" href="services.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="toc.html" class="icon icon-home"> open62541
          

          
            
            <img src="_static/open62541_html.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building open62541</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing.html">Installing open62541</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="protocol.html">Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Data Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="services.html">Services</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Information Modelling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#node-lifecycle-constructors-destructors-and-node-contexts">Node Lifecycle: Constructors, Destructors and Node Contexts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#global-node-lifecycle">Global Node Lifecycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node-type-lifecycle">Node Type Lifecycle</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#referencetype-bitfield-representation">ReferenceType Bitfield Representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#base-node-attributes">Base Node Attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variablenode">VariableNode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-type">Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-rank">Value Rank</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array-dimensions">Array Dimensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-callback">Value Callback</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variabletypenode">VariableTypeNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#methodnode">MethodNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#objectnode">ObjectNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#objecttypenode">ObjectTypeNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#referencetypenode">ReferenceTypeNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#datatypenode">DataTypeNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#viewnode">ViewNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#node-union">Node Union</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nodestore-plugin-api">Nodestore Plugin API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="server.html">Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="client.html">Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="common.html">Common Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nodeset_compiler.html">XML Nodeset Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="internal.html">Internals</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="toc.html">open62541</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="toc.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Information Modelling</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/nodestore.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="information-modelling">
<span id="id1"></span><h1>Information Modelling<a class="headerlink" href="#information-modelling" title="Permalink to this headline">¶</a></h1>
<p>Information modelling in OPC UA combines concepts from object-orientation and
semantic modelling. At the core, an OPC UA information model is a graph made
up of</p>
<ul class="simple">
<li><p>Nodes: There are eight possible Node types (variable, object, method, …)</p></li>
<li><p>References: Typed and directed relations between two nodes</p></li>
</ul>
<p>Every node is identified by a unique (within the server) <a class="reference internal" href="types.html#nodeid"><span class="std std-ref">NodeId</span></a>.
Reference are triples of the form <code class="docutils literal notranslate"><span class="pre">(source-nodeid,</span> <span class="pre">referencetype-nodeid,</span>
<span class="pre">target-nodeid)</span></code>. An example reference between nodes is a
<code class="docutils literal notranslate"><span class="pre">hasTypeDefinition</span></code> reference between a Variable and its VariableType. Some
ReferenceTypes are <em>hierarchic</em> and must not form <em>directed loops</em>. See the
section on <a class="reference internal" href="#referencetypenode"><span class="std std-ref">ReferenceTypes</span></a> for more details on
possible references and their semantics.</p>
<p><strong>Warning!!</strong> The structures defined in this section are only relevant for
the developers of custom Nodestores. The interaction with the information
model is possible only via the OPC UA <a class="reference internal" href="services.html#services"><span class="std std-ref">Services</span></a>. So the following
sections are purely informational so that users may have a clear mental
model of the underlying representation.</p>
<div class="section" id="node-lifecycle-constructors-destructors-and-node-contexts">
<span id="node-lifecycle"></span><h2>Node Lifecycle: Constructors, Destructors and Node Contexts<a class="headerlink" href="#node-lifecycle-constructors-destructors-and-node-contexts" title="Permalink to this headline">¶</a></h2>
<p>To finalize the instantiation of a node, a (user-defined) constructor
callback is executed. There can be both a global constructor for all nodes
and node-type constructor specific to the TypeDefinition of the new node
(attached to an ObjectTypeNode or VariableTypeNode).</p>
<p>In the hierarchy of ObjectTypes and VariableTypes, only the constructor of
the (lowest) type defined for the new node is executed. Note that every
Object and Variable can have only one <code class="docutils literal notranslate"><span class="pre">isTypeOf</span></code> reference. But type-nodes
can technically have several <code class="docutils literal notranslate"><span class="pre">hasSubType</span></code> references to implement multiple
inheritance. Issues of (multiple) inheritance in the constructor need to be
solved by the user.</p>
<p>When a node is destroyed, the node-type destructor is called before the
global destructor. So the overall node lifecycle is as follows:</p>
<ol class="arabic simple">
<li><p>Global Constructor (set in the server config)</p></li>
<li><p>Node-Type Constructor (for VariableType or ObjectTypes)</p></li>
<li><p>(Usage-period of the Node)</p></li>
<li><p>Node-Type Destructor</p></li>
<li><p>Global Destructor</p></li>
</ol>
<p>The constructor and destructor callbacks can be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and are not
used in that case. If the node-type constructor fails, the global destructor
will be called before removing the node. The destructors are assumed to never
fail.</p>
<p>Every node carries a user-context and a constructor-context pointer. The
user-context is used to attach custom data to a node. But the (user-defined)
constructors and destructors may replace the user-context pointer if they
wish to do so. The initial value for the constructor-context is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
When the <code class="docutils literal notranslate"><span class="pre">AddNodes</span></code> service is used over the network, the user-context
pointer of the new node is also initially set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="section" id="global-node-lifecycle">
<h3>Global Node Lifecycle<a class="headerlink" href="#global-node-lifecycle" title="Permalink to this headline">¶</a></h3>
<p>Global constructor and destructor callbacks used for every node type.
To be set in the server config.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* Can be NULL. May replace the nodeContext */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">constructor</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">nodeContext</span><span class="p">);</span>

    <span class="cm">/* Can be NULL. The context cannot be replaced since the node is destroyed</span>
<span class="cm">     * immediately afterwards anyway. */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">);</span>

    <span class="cm">/* Can be NULL. Called during recursive node instantiation. While mandatory</span>
<span class="cm">     * child nodes are automatically created if not already present, optional child</span>
<span class="cm">     * nodes are not. This callback can be used to define whether an optional child</span>
<span class="cm">     * node should be created.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param sourceNodeId Source node from the type definition. If the new node</span>
<span class="cm">     *        shall be created, it will be a copy of this node.</span>
<span class="cm">     * @param targetParentNodeId Parent of the potential new child node</span>
<span class="cm">     * @param referenceTypeId Identifies the reference type which that the parent</span>
<span class="cm">     *        node has to the new node.</span>
<span class="cm">     * @return Return UA_TRUE if the child node shall be instantiated,</span>
<span class="cm">     *         UA_FALSE otherwise. */</span>
    <span class="n">UA_Boolean</span> <span class="p">(</span><span class="o">*</span><span class="n">createOptionalChild</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                                      <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sourceNodeId</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">targetParentNodeId</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">referenceTypeId</span><span class="p">);</span>

    <span class="cm">/* Can be NULL. Called when a node is to be copied during recursive</span>
<span class="cm">     * node instantiation. Allows definition of the NodeId for the new node.</span>
<span class="cm">     * If the callback is set to NULL or the resulting NodeId is UA_NODEID_NUMERIC(X,0)</span>
<span class="cm">     * an unused nodeid in namespace X will be used. E.g. passing UA_NODEID_NULL will</span>
<span class="cm">     * result in a NodeId in namespace 0.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param sourceNodeId Source node of the copy operation</span>
<span class="cm">     * @param targetParentNodeId Parent node of the new node</span>
<span class="cm">     * @param referenceTypeId Identifies the reference type which that the parent</span>
<span class="cm">     *        node has to the new node. */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">generateChildNodeId</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sourceNodeId</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">targetParentNodeId</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">referenceTypeId</span><span class="p">,</span>
                                         <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">targetNodeId</span><span class="p">);</span>
<span class="p">}</span> <span class="n">UA_GlobalNodeLifecycle</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="node-type-lifecycle">
<h3>Node Type Lifecycle<a class="headerlink" href="#node-type-lifecycle" title="Permalink to this headline">¶</a></h3>
<p>Constructor and destructors for specific object and variable types.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* Can be NULL. May replace the nodeContext */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">constructor</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">typeNodeId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">typeNodeContext</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">nodeContext</span><span class="p">);</span>

    <span class="cm">/* Can be NULL. May replace the nodeContext. */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">typeNodeId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">typeNodeContext</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">nodeContext</span><span class="p">);</span>
<span class="p">}</span> <span class="n">UA_NodeTypeLifecycle</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="referencetype-bitfield-representation">
<h2>ReferenceType Bitfield Representation<a class="headerlink" href="#referencetype-bitfield-representation" title="Permalink to this headline">¶</a></h2>
<p>ReferenceTypes have an alternative represention as an index into a bitfield
for fast comparison. The index is generated when the corresponding
ReferenceTypeNode is added. By bounding the number of ReferenceTypes that can
exist in the server, the bitfield can represent a set of an combination of
ReferenceTypes.</p>
<p>Every ReferenceTypeNode contains a bitfield with the set of all its subtypes.
This speeds up the Browse services substantially.</p>
<p>The following ReferenceTypes have a fixed index. The NS0 bootstrapping
creates these ReferenceTypes in-order.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define UA_REFERENCETYPEINDEX_REFERENCES 0</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASSUBTYPE 1</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_AGGREGATES 2</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HIERARCHICALREFERENCES 3</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_NONHIERARCHICALREFERENCES 4</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASCHILD 5</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_ORGANIZES 6</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASEVENTSOURCE 7</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASMODELLINGRULE 8</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASENCODING 9</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASDESCRIPTION 10</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASTYPEDEFINITION 11</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_GENERATESEVENT 12</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASPROPERTY 13</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASCOMPONENT 14</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASNOTIFIER 15</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASORDEREDCOMPONENT 16</span>
<span class="cp">#define UA_REFERENCETYPEINDEX_HASINTERFACE 17</span>

<span class="cm">/* The maximum number of ReferrenceTypes. Must be a multiple of 32. */</span>
<span class="cp">#define UA_REFERENCETYPESET_MAX 128</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">UA_UInt32</span> <span class="n">bits</span><span class="p">[</span><span class="n">UA_REFERENCETYPESET_MAX</span> <span class="o">/</span> <span class="mi">32</span><span class="p">];</span> <span class="p">}</span> <span class="n">UA_ReferenceTypeSet</span><span class="p">;</span>

<span class="k">static</span> <span class="n">UA_INLINE</span> <span class="kt">void</span>
<span class="n">UA_ReferenceTypeSet_init</span><span class="p">(</span><span class="n">UA_ReferenceTypeSet</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UA_ReferenceTypeSet</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">UA_INLINE</span> <span class="kt">void</span>
<span class="n">UA_ReferenceTypeSet_any</span><span class="p">(</span><span class="n">UA_ReferenceTypeSet</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UA_ReferenceTypeSet</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">UA_INLINE</span> <span class="n">UA_ReferenceTypeSet</span>
<span class="n">UA_REFTYPESET</span><span class="p">(</span><span class="n">UA_Byte</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UA_Byte</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">/</span> <span class="mi">32</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">UA_ReferenceTypeSet</span> <span class="n">set</span><span class="p">;</span>
    <span class="n">UA_ReferenceTypeSet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
    <span class="n">set</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="p">((</span><span class="n">UA_UInt32</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">UA_INLINE</span> <span class="n">UA_ReferenceTypeSet</span>
<span class="n">UA_ReferenceTypeSet_union</span><span class="p">(</span><span class="k">const</span> <span class="n">UA_ReferenceTypeSet</span> <span class="n">setA</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">UA_ReferenceTypeSet</span> <span class="n">setB</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UA_ReferenceTypeSet</span> <span class="n">set</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UA_REFERENCETYPESET_MAX</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">set</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">setA</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">setB</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">UA_INLINE</span> <span class="n">UA_Boolean</span>
<span class="n">UA_ReferenceTypeSet_contains</span><span class="p">(</span><span class="k">const</span> <span class="n">UA_ReferenceTypeSet</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">UA_Byte</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UA_Byte</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">/</span> <span class="mi">32</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">32</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(((</span><span class="n">UA_UInt32</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="base-node-attributes">
<h2>Base Node Attributes<a class="headerlink" href="#base-node-attributes" title="Permalink to this headline">¶</a></h2>
<p>Nodes contain attributes according to their node type. The base node
attributes are common to all node types. In the OPC UA <a class="reference internal" href="services.html#services"><span class="std std-ref">Services</span></a>,
attributes are referred to via the <a class="reference internal" href="types.html#nodeid"><span class="std std-ref">NodeId</span></a> of the containing node and
an integer <a class="reference internal" href="common.html#attribute-id"><span class="std std-ref">Attribute Id</span></a>.</p>
<p>Internally, open62541 uses <code class="docutils literal notranslate"><span class="pre">UA_Node</span></code> in places where the exact node type is
not known or not important. The <code class="docutils literal notranslate"><span class="pre">nodeClass</span></code> attribute is used to ensure the
correctness of casting from <code class="docutils literal notranslate"><span class="pre">UA_Node</span></code> to a specific node type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Ordered tree structure for fast member check */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">UA_ReferenceTarget</span> <span class="p">{</span>
    <span class="cm">/* Binary-Tree for fast lookup */</span>
    <span class="k">struct</span> <span class="nc">aa_entry</span> <span class="n">idTreeEntry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">aa_entry</span> <span class="n">nameTreeEntry</span><span class="p">;</span>
    <span class="n">UA_UInt32</span> <span class="n">targetIdHash</span><span class="p">;</span>   <span class="cm">/* Hash of the target&#39;s NodeId */</span>
    <span class="n">UA_UInt32</span> <span class="n">targetNameHash</span><span class="p">;</span> <span class="cm">/* Hash of the target&#39;s BrowseName */</span>

    <span class="cm">/* Emulate the queue.h structure so we don&#39;t have to include it in the</span>
<span class="cm">     * public API */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">UA_ReferenceTarget</span> <span class="o">*</span><span class="n">tqe_next</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">UA_ReferenceTarget</span> <span class="o">**</span><span class="n">tqe_prev</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">queuePointers</span><span class="p">;</span>

    <span class="n">UA_ExpandedNodeId</span> <span class="n">targetId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_ReferenceTarget</span><span class="p">;</span>

<span class="cm">/* List of reference targets with the same reference type and direction */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_Byte</span> <span class="n">referenceTypeIndex</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">isInverse</span><span class="p">;</span>

    <span class="cm">/* Emulate the queue.h structure so we don&#39;t have to include it in the</span>
<span class="cm">     * public API */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">UA_ReferenceTarget</span> <span class="o">*</span><span class="n">tqh_first</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">UA_ReferenceTarget</span> <span class="o">**</span><span class="n">tqh_last</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">queueHead</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">aa_entry</span> <span class="o">*</span><span class="n">idTreeRoot</span><span class="p">;</span>   <span class="cm">/* Fast lookup based on the target id */</span>
    <span class="k">struct</span> <span class="nc">aa_entry</span> <span class="o">*</span><span class="n">nameTreeRoot</span><span class="p">;</span> <span class="cm">/* Fast lookup based on the target browseName*/</span>
<span class="p">}</span> <span class="n">UA_NodeReferenceKind</span><span class="p">;</span>

<span class="cm">/* Every Node starts with these attributes */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeId</span> <span class="n">nodeId</span><span class="p">;</span>
    <span class="n">UA_NodeClass</span> <span class="n">nodeClass</span><span class="p">;</span>
    <span class="n">UA_QualifiedName</span> <span class="n">browseName</span><span class="p">;</span>
    <span class="n">UA_LocalizedText</span> <span class="n">displayName</span><span class="p">;</span>
    <span class="n">UA_LocalizedText</span> <span class="n">description</span><span class="p">;</span>
    <span class="n">UA_UInt32</span> <span class="n">writeMask</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">referencesSize</span><span class="p">;</span>
    <span class="n">UA_NodeReferenceKind</span> <span class="o">*</span><span class="n">references</span><span class="p">;</span>

    <span class="cm">/* Members specific to open62541 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">constructed</span><span class="p">;</span> <span class="cm">/* Constructors were called */</span>
<span class="p">}</span> <span class="n">UA_NodeHead</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="variablenode">
<h2>VariableNode<a class="headerlink" href="#variablenode" title="Permalink to this headline">¶</a></h2>
<p>Variables store values in a <a class="reference internal" href="types.html#datavalue"><span class="std std-ref">DataValue</span></a> together with
metadata for introspection. Most notably, the attributes data type, value
rank and array dimensions constrain the possible values the variable can take
on.</p>
<p>Variables come in two flavours: properties and datavariables. Properties are
related to a parent with a <code class="docutils literal notranslate"><span class="pre">hasProperty</span></code> reference and may not have child
nodes themselves. Datavariables may contain properties (<code class="docutils literal notranslate"><span class="pre">hasProperty</span></code>) and
also datavariables (<code class="docutils literal notranslate"><span class="pre">hasComponents</span></code>).</p>
<p>All variables are instances of some <a class="reference internal" href="#variabletypenode"><span class="std std-ref">VariableTypeNode</span></a> in return
constraining the possible data type, value rank and array dimensions
attributes.</p>
<div class="section" id="data-type">
<h3>Data Type<a class="headerlink" href="#data-type" title="Permalink to this headline">¶</a></h3>
<p>The (scalar) data type of the variable is constrained to be of a specific
type or one of its children in the type hierarchy. The data type is given as
a NodeId pointing to a <a class="reference internal" href="#datatypenode"><span class="std std-ref">DataTypeNode</span></a> in the type hierarchy. See the
Section <a class="reference internal" href="#datatypenode"><span class="std std-ref">DataTypeNode</span></a> for more details.</p>
<p>If the data type attribute points to <code class="docutils literal notranslate"><span class="pre">UInt32</span></code>, then the value attribute
must be of that exact type since <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> does not have children in the
type hierarchy. If the data type attribute points <code class="docutils literal notranslate"><span class="pre">Number</span></code>, then the type
of the value attribute may still be <code class="docutils literal notranslate"><span class="pre">UInt32</span></code>, but also <code class="docutils literal notranslate"><span class="pre">Float</span></code> or
<code class="docutils literal notranslate"><span class="pre">Byte</span></code>.</p>
<p>Consistency between the data type attribute in the variable and its
<a class="reference internal" href="#variabletypenode"><span class="std std-ref">VariableTypeNode</span></a> is ensured.</p>
</div>
<div class="section" id="value-rank">
<h3>Value Rank<a class="headerlink" href="#value-rank" title="Permalink to this headline">¶</a></h3>
<p>This attribute indicates whether the value attribute of the variable is an
array and how many dimensions the array has. It may have the following
values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code>: the value is an array with the specified number of dimensions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span>&#160; <span class="pre">0</span></code>: the value is an array with one or more dimensions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">-1</span></code>: the value is a scalar</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">-2</span></code>: the value can be a scalar or an array with any number of dimensions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">-3</span></code>: the value can be a scalar or a one dimensional array</p></li>
</ul>
<p>Consistency between the value rank attribute in the variable and its
<a class="reference internal" href="#variabletypenode"><span class="std std-ref">VariableTypeNode</span></a> is ensured.</p>
</div>
<div class="section" id="array-dimensions">
<h3>Array Dimensions<a class="headerlink" href="#array-dimensions" title="Permalink to this headline">¶</a></h3>
<p>If the value rank permits the value to be a (multi-dimensional) array, the
exact length in each dimensions can be further constrained with this
attribute.</p>
<ul class="simple">
<li><p>For positive lengths, the variable value is guaranteed to be of the same
length in this dimension.</p></li>
<li><p>The dimension length zero is a wildcard and the actual value may have any
length in this dimension.</p></li>
</ul>
<p>Consistency between the array dimensions attribute in the variable and its
<a class="reference internal" href="#variabletypenode"><span class="std std-ref">VariableTypeNode</span></a> is ensured.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Indicates whether a variable contains data inline or whether it points to an</span>
<span class="cm"> * external data source */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">UA_VALUESOURCE_DATA</span><span class="p">,</span>
    <span class="n">UA_VALUESOURCE_DATASOURCE</span>
<span class="p">}</span> <span class="n">UA_ValueSource</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* Called before the value attribute is read. It is possible to write into the</span>
<span class="cm">     * value attribute during onRead (using the write service). The node is</span>
<span class="cm">     * re-opened afterwards so that changes are considered in the following read</span>
<span class="cm">     * operation.</span>
<span class="cm">     *</span>
<span class="cm">     * @param handle Points to user-provided data for the callback.</span>
<span class="cm">     * @param nodeid The identifier of the node.</span>
<span class="cm">     * @param data Points to the current node value.</span>
<span class="cm">     * @param range Points to the numeric range the client wants to read from</span>
<span class="cm">     *        (or NULL). */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">onRead</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeid</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NumericRange</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">UA_DataValue</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>

    <span class="cm">/* Called after writing the value attribute. The node is re-opened after</span>
<span class="cm">     * writing so that the new value is visible in the callback.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @sessionId The identifier of the session</span>
<span class="cm">     * @sessionContext Additional data attached to the session</span>
<span class="cm">     *                 in the access control layer</span>
<span class="cm">     * @param nodeid The identifier of the node.</span>
<span class="cm">     * @param nodeUserContext Additional data attached to the node by</span>
<span class="cm">     *        the user.</span>
<span class="cm">     * @param nodeConstructorContext Additional data attached to the node</span>
<span class="cm">     *        by the type constructor(s).</span>
<span class="cm">     * @param range Points to the numeric range the client wants to write to (or</span>
<span class="cm">     *        NULL). */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">onWrite</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                    <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
                    <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NumericRange</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">UA_DataValue</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span> <span class="n">UA_ValueCallback</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* Copies the data from the source into the provided value.</span>
<span class="cm">     *</span>
<span class="cm">     * !! ZERO-COPY OPERATIONS POSSIBLE !!</span>
<span class="cm">     * It is not required to return a copy of the actual content data. You can</span>
<span class="cm">     * return a pointer to memory owned by the user. Memory can be reused</span>
<span class="cm">     * between read callbacks of a DataSource, as the result is already encoded</span>
<span class="cm">     * on the network buffer between each read operation.</span>
<span class="cm">     *</span>
<span class="cm">     * To use zero-copy reads, set the value of the `value-&gt;value` Variant</span>
<span class="cm">     * without copying, e.g. with `UA_Variant_setScalar`. Then, also set</span>
<span class="cm">     * `value-&gt;value.storageType` to `UA_VARIANT_DATA_NODELETE` to prevent the</span>
<span class="cm">     * memory being cleaned up. Don&#39;t forget to also set `value-&gt;hasValue` to</span>
<span class="cm">     * true to indicate the presence of a value.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param nodeId The identifier of the node being read from</span>
<span class="cm">     * @param nodeContext Additional data attached to the node by the user</span>
<span class="cm">     * @param includeSourceTimeStamp If true, then the datasource is expected to</span>
<span class="cm">     *        set the source timestamp in the returned value</span>
<span class="cm">     * @param range If not null, then the datasource shall return only a</span>
<span class="cm">     *        selection of the (nonscalar) data. Set</span>
<span class="cm">     *        UA_STATUSCODE_BADINDEXRANGEINVALID in the value if this does not</span>
<span class="cm">     *        apply</span>
<span class="cm">     * @param value The (non-null) DataValue that is returned to the client. The</span>
<span class="cm">     *        data source sets the read data, the result status and optionally a</span>
<span class="cm">     *        sourcetimestamp.</span>
<span class="cm">     * @return Returns a status code for logging. Error codes intended for the</span>
<span class="cm">     *         original caller are set in the value. If an error is returned,</span>
<span class="cm">     *         then no releasing of the value is done</span>
<span class="cm">     */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span> <span class="n">UA_Boolean</span> <span class="n">includeSourceTimeStamp</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">UA_NumericRange</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span> <span class="n">UA_DataValue</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>

    <span class="cm">/* Write into a data source. This method pointer can be NULL if the</span>
<span class="cm">     * operation is unsupported.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @param sessionId The identifier of the session</span>
<span class="cm">     * @param sessionContext Additional data attached to the session in the</span>
<span class="cm">     *        access control layer</span>
<span class="cm">     * @param nodeId The identifier of the node being written to</span>
<span class="cm">     * @param nodeContext Additional data attached to the node by the user</span>
<span class="cm">     * @param range If not NULL, then the datasource shall return only a</span>
<span class="cm">     *        selection of the (nonscalar) data. Set</span>
<span class="cm">     *        UA_STATUSCODE_BADINDEXRANGEINVALID in the value if this does not</span>
<span class="cm">     *        apply</span>
<span class="cm">     * @param value The (non-NULL) DataValue that has been written by the client.</span>
<span class="cm">     *        The data source contains the written data, the result status and</span>
<span class="cm">     *        optionally a sourcetimestamp</span>
<span class="cm">     * @return Returns a status code for logging. Error codes intended for the</span>
<span class="cm">     *         original caller are set in the value. If an error is returned,</span>
<span class="cm">     *         then no releasing of the value is done</span>
<span class="cm">     */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NumericRange</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">UA_DataValue</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span> <span class="n">UA_DataSource</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="value-callback">
<span id="id2"></span><h3>Value Callback<a class="headerlink" href="#value-callback" title="Permalink to this headline">¶</a></h3>
<p>Value Callbacks can be attached to variable and variable type nodes. If
not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, they are called before reading and after writing respectively.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* Called before the value attribute is read. The external value source can be</span>
<span class="cm">     * be updated and/or locked during this notification call. After this function returns</span>
<span class="cm">     * to the core, the external value source is readed immediately.</span>
<span class="cm">    */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">notificationRead</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                                      <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeid</span><span class="p">,</span>
                                      <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NumericRange</span> <span class="o">*</span><span class="n">range</span><span class="p">);</span>

    <span class="cm">/* Called after writing the value attribute. The node is re-opened after</span>
<span class="cm">     * writing so that the new value is visible in the callback.</span>
<span class="cm">     *</span>
<span class="cm">     * @param server The server executing the callback</span>
<span class="cm">     * @sessionId The identifier of the session</span>
<span class="cm">     * @sessionContext Additional data attached to the session</span>
<span class="cm">     *                 in the access control layer</span>
<span class="cm">     * @param nodeid The identifier of the node.</span>
<span class="cm">     * @param nodeUserContext Additional data attached to the node by</span>
<span class="cm">     *        the user.</span>
<span class="cm">     * @param nodeConstructorContext Additional data attached to the node</span>
<span class="cm">     *        by the type constructor(s).</span>
<span class="cm">     * @param range Points to the numeric range the client wants to write to (or</span>
<span class="cm">     *        NULL). */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">userWrite</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">nodeContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NumericRange</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">UA_DataValue</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span> <span class="n">UA_ExternalValueCallback</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">UA_VALUEBACKENDTYPE_NONE</span><span class="p">,</span>
    <span class="n">UA_VALUEBACKENDTYPE_INTERNAL</span><span class="p">,</span>
    <span class="n">UA_VALUEBACKENDTYPE_DATA_SOURCE_CALLBACK</span><span class="p">,</span>
    <span class="n">UA_VALUEBACKENDTYPE_EXTERNAL</span>
<span class="p">}</span> <span class="n">UA_ValueBackendType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_ValueBackendType</span> <span class="n">backendType</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">UA_DataValue</span> <span class="n">value</span><span class="p">;</span>
            <span class="n">UA_ValueCallback</span> <span class="n">callback</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">internal</span><span class="p">;</span>
        <span class="n">UA_DataSource</span> <span class="n">dataSource</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">UA_DataValue</span> <span class="o">**</span><span class="n">value</span><span class="p">;</span>
            <span class="n">UA_ExternalValueCallback</span> <span class="n">callback</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">external</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">backend</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_ValueBackend</span><span class="p">;</span>

<span class="cp">#define UA_NODE_VARIABLEATTRIBUTES                                      \</span>
<span class="cp">    </span><span class="cm">/* Constraints on possible values */</span><span class="cp">                                \</span>
<span class="cp">    UA_NodeId dataType;                                                 \</span>
<span class="cp">    UA_Int32 valueRank;                                                 \</span>
<span class="cp">    size_t arrayDimensionsSize;                                         \</span>
<span class="cp">    UA_UInt32 *arrayDimensions;                                         \</span>
<span class="cp">                                                                        \</span>
<span class="cp">    UA_ValueBackend valueBackend;                                       \</span>
<span class="cp">                                                                        \</span>
<span class="cp">    </span><span class="cm">/* The current value */</span><span class="cp">                                             \</span>
<span class="cp">    UA_ValueSource valueSource;                                         \</span>
<span class="cp">    union {                                                             \</span>
<span class="cp">        struct {                                                        \</span>
<span class="cp">            UA_DataValue value;                                         \</span>
<span class="cp">            UA_ValueCallback callback;                                  \</span>
<span class="cp">        } data;                                                         \</span>
<span class="cp">        UA_DataSource dataSource;                                       \</span>
<span class="cp">    } value;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_NODE_VARIABLEATTRIBUTES</span>
    <span class="n">UA_Byte</span> <span class="n">accessLevel</span><span class="p">;</span>
    <span class="n">UA_Double</span> <span class="n">minimumSamplingInterval</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">historizing</span><span class="p">;</span>

    <span class="cm">/* Members specific to open62541 */</span>
    <span class="n">UA_Boolean</span> <span class="n">isDynamic</span><span class="p">;</span> <span class="cm">/* Some variables are &quot;static&quot; in the sense that they</span>
<span class="cm">                           * are not attached to a dynamic process in the</span>
<span class="cm">                           * background. Only dynamic variables conserve source</span>
<span class="cm">                           * and server timestamp for the value attribute.</span>
<span class="cm">                           * Static variables have timestamps of &quot;now&quot;. */</span>
<span class="p">}</span> <span class="n">UA_VariableNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="variabletypenode">
<span id="id3"></span><h2>VariableTypeNode<a class="headerlink" href="#variabletypenode" title="Permalink to this headline">¶</a></h2>
<p>VariableTypes are used to provide type definitions for variables.
VariableTypes constrain the data type, value rank and array dimensions
attributes of variable instances. Furthermore, instantiating from a specific
variable type may provide semantic information. For example, an instance from
<code class="docutils literal notranslate"><span class="pre">MotorTemperatureVariableType</span></code> is more meaningful than a float variable
instantiated from <code class="docutils literal notranslate"><span class="pre">BaseDataVariable</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_NODE_VARIABLEATTRIBUTES</span>
    <span class="n">UA_Boolean</span> <span class="n">isAbstract</span><span class="p">;</span>

    <span class="cm">/* Members specific to open62541 */</span>
    <span class="n">UA_NodeTypeLifecycle</span> <span class="n">lifecycle</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_VariableTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="methodnode">
<span id="id4"></span><h2>MethodNode<a class="headerlink" href="#methodnode" title="Permalink to this headline">¶</a></h2>
<p>Methods define callable functions and are invoked using the <a class="reference internal" href="services.html#method-services"><span class="std std-ref">Call</span></a> service. MethodNodes may have special properties (variable
children with a <code class="docutils literal notranslate"><span class="pre">hasProperty</span></code> reference) with the <a class="reference internal" href="types.html#qualifiedname"><span class="std std-ref">QualifiedName</span></a> <code class="docutils literal notranslate"><span class="pre">(0,</span>
<span class="pre">&quot;InputArguments&quot;)</span></code> and <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">&quot;OutputArguments&quot;)</span></code>. The input and output
arguments are both described via an array of <code class="docutils literal notranslate"><span class="pre">UA_Argument</span></code>. While the Call
service uses a generic array of <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a> for input and output, the
actual argument values are checked to match the signature of the MethodNode.</p>
<p>Note that the same MethodNode may be referenced from several objects (and
object types). For this, the NodeId of the method <em>and of the object
providing context</em> is part of a Call request message.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="nf">UA_StatusCode</span>
<span class="p">(</span><span class="o">*</span><span class="n">UA_MethodCallback</span><span class="p">)(</span><span class="n">UA_Server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">sessionId</span><span class="p">,</span>
                     <span class="kt">void</span> <span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">methodId</span><span class="p">,</span>
                     <span class="kt">void</span> <span class="o">*</span><span class="n">methodContext</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">objectId</span><span class="p">,</span>
                     <span class="kt">void</span> <span class="o">*</span><span class="n">objectContext</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inputSize</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">UA_Variant</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">outputSize</span><span class="p">,</span>
                     <span class="n">UA_Variant</span> <span class="o">*</span><span class="n">output</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">executable</span><span class="p">;</span>

    <span class="cm">/* Members specific to open62541 */</span>
    <span class="n">UA_MethodCallback</span> <span class="n">method</span><span class="p">;</span>
<span class="cp">#if UA_MULTITHREADING &gt;= 100</span>
    <span class="n">UA_Boolean</span> <span class="n">async</span><span class="p">;</span> <span class="cm">/* Indicates an async method call */</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">UA_MethodNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="objectnode">
<h2>ObjectNode<a class="headerlink" href="#objectnode" title="Permalink to this headline">¶</a></h2>
<p>Objects are used to represent systems, system components, real-world objects
and software objects. Objects are instances of an <a class="reference internal" href="#objecttypenode"><span class="std std-ref">object
type</span></a> and may contain variables, methods and further
objects.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
<span class="cp">#ifdef UA_ENABLE_SUBSCRIPTIONS_EVENTS</span>
    <span class="k">struct</span> <span class="nc">UA_MonitoredItem</span> <span class="o">*</span><span class="n">monitoredItemQueue</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="n">UA_Byte</span> <span class="n">eventNotifier</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_ObjectNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="objecttypenode">
<span id="id5"></span><h2>ObjectTypeNode<a class="headerlink" href="#objecttypenode" title="Permalink to this headline">¶</a></h2>
<p>ObjectTypes provide definitions for Objects. Abstract objects cannot be
instantiated. See <a class="reference internal" href="#node-lifecycle"><span class="std std-ref">Node Lifecycle: Constructors, Destructors and Node Contexts</span></a> for the use of constructor and
destructor callbacks.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">isAbstract</span><span class="p">;</span>

    <span class="cm">/* Members specific to open62541 */</span>
    <span class="n">UA_NodeTypeLifecycle</span> <span class="n">lifecycle</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_ObjectTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="referencetypenode">
<span id="id6"></span><h2>ReferenceTypeNode<a class="headerlink" href="#referencetypenode" title="Permalink to this headline">¶</a></h2>
<p>Each reference between two nodes is typed with a ReferenceType that gives
meaning to the relation. The OPC UA standard defines a set of ReferenceTypes
as a mandatory part of OPC UA information models.</p>
<ul class="simple">
<li><p>Abstract ReferenceTypes cannot be used in actual references and are only
used to structure the ReferenceTypes hierarchy</p></li>
<li><p>Symmetric references have the same meaning from the perspective of the
source and target node</p></li>
</ul>
<p>The figure below shows the hierarchy of the standard ReferenceTypes (arrows
indicate a <code class="docutils literal notranslate"><span class="pre">hasSubType</span></code> relation). Refer to Part 3 of the OPC UA
specification for the full semantics of each ReferenceType.</p>
<div class="graphviz"><img src="_images/graphviz-c70caf8c77d83c33c89ce7854854be2352ef5077.png" alt="digraph tree {

node [height=0, shape=box, fillcolor=&quot;#E5E5E5&quot;, concentrate=true]

references [label=&quot;References\n(Abstract, Symmetric)&quot;]
hierarchical_references [label=&quot;HierarchicalReferences\n(Abstract)&quot;]
references -&gt; hierarchical_references

nonhierarchical_references [label=&quot;NonHierarchicalReferences\n(Abstract, Symmetric)&quot;]
references -&gt; nonhierarchical_references

haschild [label=&quot;HasChild\n(Abstract)&quot;]
hierarchical_references -&gt; haschild

aggregates [label=&quot;Aggregates\n(Abstract)&quot;]
haschild -&gt; aggregates

organizes [label=&quot;Organizes&quot;]
hierarchical_references -&gt; organizes

hascomponent [label=&quot;HasComponent&quot;]
aggregates -&gt; hascomponent

hasorderedcomponent [label=&quot;HasOrderedComponent&quot;]
hascomponent -&gt; hasorderedcomponent

hasproperty [label=&quot;HasProperty&quot;]
aggregates -&gt; hasproperty

hassubtype [label=&quot;HasSubtype&quot;]
haschild -&gt; hassubtype

hasmodellingrule [label=&quot;HasModellingRule&quot;]
nonhierarchical_references -&gt; hasmodellingrule

hastypedefinition [label=&quot;HasTypeDefinition&quot;]
nonhierarchical_references -&gt; hastypedefinition

hasencoding [label=&quot;HasEncoding&quot;]
nonhierarchical_references -&gt; hasencoding

hasdescription [label=&quot;HasDescription&quot;]
nonhierarchical_references -&gt; hasdescription

haseventsource [label=&quot;HasEventSource&quot;]
hierarchical_references -&gt; haseventsource

hasnotifier [label=&quot;HasNotifier&quot;]
hierarchical_references -&gt; hasnotifier

generatesevent [label=&quot;GeneratesEvent&quot;]
nonhierarchical_references -&gt; generatesevent

alwaysgeneratesevent [label=&quot;AlwaysGeneratesEvent&quot;]
generatesevent -&gt; alwaysgeneratesevent

{rank=same hierarchical_references nonhierarchical_references}
{rank=same generatesevent haseventsource hasmodellingrule
           hasencoding hassubtype}
{rank=same alwaysgeneratesevent hasproperty}

}" class="graphviz" /></div>
<p>The ReferenceType hierarchy can be extended with user-defined ReferenceTypes.
Many Companion Specifications for OPC UA define new ReferenceTypes to be used
in their domain of interest.</p>
<p>For the following example of custom ReferenceTypes, we attempt to model the
structure of a technical system. For this, we introduce two custom
ReferenceTypes. First, the hierarchical <code class="docutils literal notranslate"><span class="pre">contains</span></code> ReferenceType indicates
that a system (represented by an OPC UA object) contains a component (or
subsystem). This gives rise to a tree-structure of containment relations. For
example, the motor (object) is contained in the car and the crankshaft is
contained in the motor. Second, the symmetric <code class="docutils literal notranslate"><span class="pre">connectedTo</span></code> ReferenceType
indicates that two components are connected. For example, the motor’s
crankshaft is connected to the gear box. Connections are independent of the
containment hierarchy and can induce a general graph-structure. Further
subtypes of <code class="docutils literal notranslate"><span class="pre">connectedTo</span></code> could be used to differentiate between physical,
electrical and information related connections. A client can then learn the
layout of a (physical) system represented in an OPC UA information model
based on a common understanding of just two custom reference types.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">isAbstract</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">symmetric</span><span class="p">;</span>
    <span class="n">UA_LocalizedText</span> <span class="n">inverseName</span><span class="p">;</span>

    <span class="cm">/* Members specific to open62541 */</span>
    <span class="n">UA_Byte</span> <span class="n">referenceTypeIndex</span><span class="p">;</span>
    <span class="n">UA_ReferenceTypeSet</span> <span class="n">subTypes</span><span class="p">;</span> <span class="cm">/* contains the type itself as well */</span>
<span class="p">}</span> <span class="n">UA_ReferenceTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="datatypenode">
<span id="id7"></span><h2>DataTypeNode<a class="headerlink" href="#datatypenode" title="Permalink to this headline">¶</a></h2>
<p>DataTypes represent simple and structured data types. DataTypes may contain
arrays. But they always describe the structure of a single instance. In
open62541, DataTypeNodes in the information model hierarchy are matched to
<code class="docutils literal notranslate"><span class="pre">UA_DataType</span></code> type descriptions for <a class="reference internal" href="types.html#generic-types"><span class="std std-ref">Generic Type Handling</span></a> via their NodeId.</p>
<p>Abstract DataTypes (e.g. <code class="docutils literal notranslate"><span class="pre">Number</span></code>) cannot be the type of actual values.
They are used to constrain values to possible child DataTypes (e.g.
<code class="docutils literal notranslate"><span class="pre">UInt32</span></code>).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">isAbstract</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_DataTypeNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="viewnode">
<h2>ViewNode<a class="headerlink" href="#viewnode" title="Permalink to this headline">¶</a></h2>
<p>Each View defines a subset of the Nodes in the AddressSpace. Views can be
used when browsing an information model to focus on a subset of nodes and
references only. ViewNodes can be created and be interacted with. But their
use in the <a class="reference internal" href="services.html#view-services"><span class="std std-ref">Browse</span></a> service is currently unsupported in
open62541.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_Byte</span> <span class="n">eventNotifier</span><span class="p">;</span>
    <span class="n">UA_Boolean</span> <span class="n">containsNoLoops</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_ViewNode</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="node-union">
<h2>Node Union<a class="headerlink" href="#node-union" title="Permalink to this headline">¶</a></h2>
<p>A union that represents any kind of node. The node head can always be used.
Check the NodeClass before accessing specific content.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
    <span class="n">UA_NodeHead</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">UA_VariableNode</span> <span class="n">variableNode</span><span class="p">;</span>
    <span class="n">UA_VariableTypeNode</span> <span class="n">variableTypeNode</span><span class="p">;</span>
    <span class="n">UA_MethodNode</span> <span class="n">methodNode</span><span class="p">;</span>
    <span class="n">UA_ObjectNode</span> <span class="n">objectNode</span><span class="p">;</span>
    <span class="n">UA_ObjectTypeNode</span> <span class="n">objectTypeNode</span><span class="p">;</span>
    <span class="n">UA_ReferenceTypeNode</span> <span class="n">referenceTypeNode</span><span class="p">;</span>
    <span class="n">UA_DataTypeNode</span> <span class="n">dataTypeNode</span><span class="p">;</span>
    <span class="n">UA_ViewNode</span> <span class="n">viewNode</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UA_Node</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="nodestore-plugin-api">
<h2>Nodestore Plugin API<a class="headerlink" href="#nodestore-plugin-api" title="Permalink to this headline">¶</a></h2>
<p>The following definitions are used for implementing custom node storage
backends. <strong>Most users will want to use the default nodestore and don’t need
to work with the nodestore API</strong>.</p>
<p>Outside of custom nodestore implementations, users should not manually edit
nodes. Please use the OPC UA services for that. Otherwise, all consistency
checks are omitted. This can crash the application eventually.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">UA_NodestoreVisitor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">visitorCtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* Nodestore context and lifecycle */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">);</span>

    <span class="cm">/* The following definitions are used to create empty nodes of the different</span>
<span class="cm">     * node types. The memory is managed by the nodestore. Therefore, the node</span>
<span class="cm">     * has to be removed via a special deleteNode function. (If the new node is</span>
<span class="cm">     * not added to the nodestore.) */</span>
    <span class="n">UA_Node</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">newNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="n">UA_NodeClass</span> <span class="n">nodeClass</span><span class="p">);</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deleteNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="cm">/* ``Get`` returns a pointer to an immutable node. ``Release`` indicates</span>
<span class="cm">     * that the pointer is no longer accessed afterwards. */</span>
    <span class="k">const</span> <span class="n">UA_Node</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">getNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">);</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">releaseNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="cm">/* Returns an editable copy of a node (needs to be deleted with the</span>
<span class="cm">     * deleteNode function or inserted / replaced into the nodestore). */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">getNodeCopy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">,</span>
                                 <span class="n">UA_Node</span> <span class="o">**</span><span class="n">outNode</span><span class="p">);</span>

    <span class="cm">/* Inserts a new node into the nodestore. If the NodeId is zero, then a</span>
<span class="cm">     * fresh numeric NodeId is assigned. If insertion fails, the node is</span>
<span class="cm">     * deleted. */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">insertNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
                                <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">addedNodeId</span><span class="p">);</span>

    <span class="cm">/* To replace a node, get an editable copy of the node, edit and replace</span>
<span class="cm">     * with this function. If the node was already replaced since the copy was</span>
<span class="cm">     * made, UA_STATUSCODE_BADINTERNALERROR is returned. If the NodeId is not</span>
<span class="cm">     * found, UA_STATUSCODE_BADNODEIDUNKNOWN is returned. In both error cases,</span>
<span class="cm">     * the editable node is deleted. */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">replaceNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="cm">/* Removes a node from the nodestore. */</span>
    <span class="n">UA_StatusCode</span> <span class="p">(</span><span class="o">*</span><span class="n">removeNode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span><span class="n">nodeId</span><span class="p">);</span>

    <span class="cm">/* Maps the ReferenceTypeIndex used for the references to the NodeId of the</span>
<span class="cm">     * ReferenceType. The returned pointer is stable until the Nodestore is</span>
<span class="cm">     * deleted. */</span>
    <span class="k">const</span> <span class="n">UA_NodeId</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">getReferenceTypeId</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="n">UA_Byte</span> <span class="n">refTypeIndex</span><span class="p">);</span>

    <span class="cm">/* Execute a callback for every node in the nodestore. */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">iterate</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nsCtx</span><span class="p">,</span> <span class="n">UA_NodestoreVisitor</span> <span class="n">visitor</span><span class="p">,</span>
                    <span class="kt">void</span> <span class="o">*</span><span class="n">visitorCtx</span><span class="p">);</span>
<span class="p">}</span> <span class="n">UA_Nodestore</span><span class="p">;</span>

<span class="cm">/* Attributes must be of a matching type (VariableAttributes, ObjectAttributes,</span>
<span class="cm"> * and so on). The attributes are copied. Note that the attributes structs do</span>
<span class="cm"> * not contain NodeId, NodeClass and BrowseName. The NodeClass of the node needs</span>
<span class="cm"> * to be correctly set before calling this method. UA_Node_clear is called on</span>
<span class="cm"> * the node when an error occurs internally. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_setAttributes</span><span class="p">(</span><span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">attributes</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">UA_DataType</span> <span class="o">*</span><span class="n">attributeType</span><span class="p">);</span>

<span class="cm">/* Reset the destination node and copy the content of the source */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>

<span class="cm">/* Allocate new node and copy the values from src */</span>
<span class="n">UA_Node</span> <span class="o">*</span>
<span class="nf">UA_Node_copy_alloc</span><span class="p">(</span><span class="k">const</span> <span class="n">UA_Node</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>

<span class="cm">/* Add a single reference to the node */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_addReference</span><span class="p">(</span><span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">UA_Byte</span> <span class="n">refTypeIndex</span><span class="p">,</span> <span class="n">UA_Boolean</span> <span class="n">isForward</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">UA_ExpandedNodeId</span> <span class="o">*</span><span class="n">targetNodeId</span><span class="p">,</span>
                     <span class="n">UA_UInt32</span> <span class="n">targetBrowseNameHash</span><span class="p">);</span>

<span class="cm">/* Delete a single reference from the node */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Node_deleteReference</span><span class="p">(</span><span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">UA_Byte</span> <span class="n">refTypeIndex</span><span class="p">,</span> <span class="n">UA_Boolean</span> <span class="n">isForward</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">UA_ExpandedNodeId</span> <span class="o">*</span><span class="n">targetNodeId</span><span class="p">);</span>

<span class="cm">/* Deletes references from the node which are not matching any type in the given</span>
<span class="cm"> * array. Could be used to e.g. delete all the references, except</span>
<span class="cm"> * &#39;HASMODELINGRULE&#39; */</span>
<span class="kt">void</span>
<span class="nf">UA_Node_deleteReferencesSubset</span><span class="p">(</span><span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">UA_ReferenceTypeSet</span> <span class="o">*</span><span class="n">keepSet</span><span class="p">);</span>

<span class="cm">/* Delete all references of the node */</span>
<span class="kt">void</span>
<span class="nf">UA_Node_deleteReferences</span><span class="p">(</span><span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/* Remove all malloc&#39;ed members of the node and reset */</span>
<span class="kt">void</span>
<span class="nf">UA_Node_clear</span><span class="p">(</span><span class="n">UA_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="server.html" class="btn btn-neutral float-right" title="Server" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="services.html" class="btn btn-neutral float-left" title="Services" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016, The open62541 authors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>